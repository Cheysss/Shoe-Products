"base" />
    </Keyboard>

    <Keyboard langid="0x047c" layout="101" keydef="base" description="Mohawk-Mohawk" />

    <Keyboard langid="0x0482" layout="102L" description="Occitan-France" >
        <HKL hkl="0x04090482" layout="101" keydef="base" />
        <HKL hkl="0xf0040482" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x046b" description="Quechua-Bolivia" >
        <HKL hkl="0x0409046b" layout="101" keydef="base" />
        <HKL hkl="0xf004046b" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x086b" description="Quechua-Ecuador" >
        <HKL hkl="0x0409086b" layout="101" keydef="base" />
        <HKL hkl="0xf004086b" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x0c6b" description="Quechua-Peru" >
        <HKL hkl="0x04090c6b" layout="101" keydef="base" />
        <HKL hkl="0xf0040c6b" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x0417" layout="102L" description="Raeto-Romance" >
        <HKL hkl="0x04090417" layout="101" keydef="base" />
        <HKL hkl="0xf0040417" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x044f" description="Sanskrit" >
        <HKL hkl="0x0409044f" layout="101" keydef="base" />
        <HKL hkl="0xf004044f" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x045b" description="Sinhala-Sri Lanka" >
        <HKL hkl="0x0409045b" layout="101" keydef="base" />
        <HKL hkl="0xf004045b" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x2c0a" description="Spanish-Argentina" >
        <HKL hkl="0x04092c0a" layout="101" keydef="base" />
        <HKL hkl="0xf0042c0a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x400a" description="Spanish-Bolivia" >
        <HKL hkl="0x0409400a" layout="101" keydef="base" />
        <HKL hkl="0xf004400a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x340a" description="Spanish-Chile" >
        <HKL hkl="0x0409340a" layout="101" keydef="base" />
        <HKL hkl="0xf004340a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x240a" description="Spanish-Colombia" >
        <HKL hkl="0x0409240a" layout="101" keydef="base" />
        <HKL hkl="0xf004240a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x140a" description="Spanish-Costa Rica" >
        <HKL hkl="0x0409140a" layout="101" keydef="base" />
        <HKL hkl="0xf004140a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x1c0a" description="Spanish-Dominican Republic" >
        <HKL hkl="0x04091c0a" layout="101" keydef="base" />
        <HKL hkl="0xf0041c0a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x300a" description="Spanish-Ecuador" >
        <HKL hkl="0x0409300a" layout="101" keydef="base" />
        <HKL hkl="0xf004300a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x440a" description="Spanish-El Salvador" >
        <HKL hkl="0x0409440a" layout="101" keydef="base" />
        <HKL hkl="0xf004440a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x100a" description="Spanish-Guatemala" >
        <HKL hkl="0x0409100a" layout="101" keydef="base" />
        <HKL hkl="0xf004100a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x480a" description="Spanish-Honduras" >
        <HKL hkl="0x0409480a" layout="101" keydef="base" />
        <HKL hkl="0xf004480a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x4c0a" description="Spanish-Nicaragua" >
        <HKL hkl="0x04094c0a" layout="101" keydef="base" />
        <HKL hkl="0xf0044c0a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x180a" description="Spanish-Panama" >
        <HKL hkl="0x0409180a" layout="101" keydef="base" />
        <HKL hkl="0xf004180a" layout="101" keydef="base" />
    </Keyboard>

    <Keyboard langid="0x3c0a" description="Spanish-Paraguaya positive 2, and we can decrement to be left with just "foo".
    let positive = 0;
    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
    // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
    // real directory, we won't need to append, unless the other conditions happen again.
    let addTrailingSlash = false;
    for (let i = 1; i < pieces.length; i++) {
        const piece = pieces[i];
        // An empty directory, could be a trailing slash, or just a double "//" in the path.
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        // If we encounter a real directory, then we don't need to append anymore.
        addTrailingSlash = false;
        // A current directory, which we can always drop.
        if (piece === '.')
            continue;
        // A parent directory, we need to see if there are any real directories we can pop. Else, we
        // have an excess of parents, and we'll need to keep the "..".
        if (piece === '..') {
            if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
            }
            else if (rel) {
                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                pieces[pointer++] = piece;
            }
            continue;
        }
        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
        // any popped or dropped directories.
        pieces[pointer++] = piece;
        positive++;
    }
    let path = '';
    for (let i = 1; i < pointer; i++) {
        path += '/' + pieces[i];
    }
    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {
        path += '/';
    }
    url.path = path;
}
/**
 * Attempts to resolve `input` URL/path relative to `base`.
 */
function resolve(input, base) {
    if (!input && !base)
        return '';
    const url = parseUrl(input);
    let inputType = url.type;
    if (base && inputType !== 7 /* Absolute */) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        switch (inputType) {
            case 1 /* Empty */:
                url.hash = baseUrl.hash;
            // fall through
            case 2 /* Hash */:
                url.query = baseUrl.query;
            // fall through
            case 3 /* Query */:
            case 4 /* RelativePath */:
                mergePaths(url, baseUrl);
            // fall through
            case 5 /* AbsolutePath */:
                // The host, user, and port are joined, you can't copy one without the others.
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
            // fall through
            case 6 /* SchemeRelative */:
                // The input doesn't have a schema at least, so we need to copy at least that over.
                url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType)
            inputType = baseType;
    }
    normalizePath(url, inputType);
    const queryHash = url.query + url.hash;
    switch (inputType) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2 /* Hash */:
        case 3 /* Query */:
            return queryHash;
        case 4 /* RelativePath */: {
            // The first char is always a "/", and we need it to be relative.
            const path = url.path.slice(1);
            if (!path)
                return queryHash || '.';
            if (isRelative(base || input) && !isRelative(path)) {
                // If base started with a leading ".", or there is no base and input started with a ".",
                // then we need to ensure that the relative path starts with a ".". We don't know if
                // relative starts with a "..", though, so check before prepending.
                return './' + path + queryHash;
            }
            return path + queryHash;
        }
        case 5 /* AbsolutePath */:
            return url.path + queryHash;
        default:
            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}

export { resolve as default };
//# sourceMappingURL=resolve-uri.mjs.map
