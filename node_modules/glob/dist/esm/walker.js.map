oD-Package~31bf3856ad364e35~wow64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-IPAM-Client-FoD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="100153" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="mitiAJUr+VHFyJZilMAxaMoLrOoWCHY1m3Q/SKS8iDg=" PayloadSize="28659" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-IPAM-Client-FoD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-IPAM-Client-FoD-Package~31bf3856ad364e35~wow64~sv-se~" InstalledSize="24486" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="he67gWylQ3FKOmaSeF8gAnfkL7tk+2FPSVpvHIJzIf4=" PayloadSize="19502" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-IPAM-Client-FoD-Package~31bf3856ad364e35~wow64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-IRDA-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="56883" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="zqUtLyXi4cZzNcWS+ZWq3NMVY0b/fQLMh7xQBdbRApc=" PayloadSize="28049" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-IRDA-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-IRDA-Package~31bf3856ad364e35~wow64~sv-se~" InstalledSize="11542" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="45E3Y2PmuQvl4EtCQEJdzIRl+BkL/hh/aSfn+ehoWjE=" PayloadSize="16532" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-IRDA-Package~31bf3856ad364e35~wow64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Media-Features-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="1692201" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="BsGQ6MCi8JNrmOcG27hJiHfPaXojp8RBfOeFkt2jXGE=" PayloadSize="276618" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-Media-Features-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Media-Features-Package~31bf3856ad364e35~wow64~sv-se~" InstalledSize="372781" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="4XZKWHp1s91oCQO8QmSfereiO+MyLpML+CGCjZXUTK8=" PayloadSize="76694" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-Media-Features-Package~31bf3856ad364e35~wow64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-MSPaint-FoD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="69617" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="vyiOP0cBIghky4scCHkRKi51Q6PhSigbcV4cpq5NKPM=" PayloadSize="28393" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-MSPaint-FoD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-MSPaint-FoD-Package~31bf3856ad364e35~wow64~sv-se~" InstalledSize="69480" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="Fbv/vAeYW7aR2pF6GdINU5CksWuKQNVL2iCeb0nx8qE=" PayloadSize="28289" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-MSPaint-FoD-Package~31bf3856ad364e35~wow64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-NetworkController-Tools-FoD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="67143" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="zVu9QqldbdUk1ymohWsJlIqhSnK9r9Aor5+4CQmwgE4=" PayloadSize="32667" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-NetworkController-Tools-FoD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-NetworkLoadBalancing-Tools-FoD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="220594" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="Siq5BePGFUP91wkW6D3xde+SArEY2UMb+DcFceonM0E=" PayloadSize="47195" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-NetworkLoadBalancing-Tools-FoD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Notepad-FoD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="24890" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="5Iosu0Q/COFseqQmOifKBiENxNcFGkIq11do+63ApOg=" PayloadSize="20893" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-Notepad-FoD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Notepad-FoD-Package~31bf3856ad364e35~wow64~sv-se~" InstalledSize="11349" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="qFaIOZ1vpV4IwPG1BO5aFWSiMpXoSLbISXpCBJ08B5Q=" PayloadSize="16324" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-Notepad-FoD-Package~31bf3856ad364e35~wow64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-PowerShell-ISE-FOD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="870810" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="CzRkvbC6j8961oTGj63mLnsrCC6QKwzSu2FPAHSrV38=" PayloadSize="303315" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-PowerShell-ISE-FOD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-PowerShell-ISE-FOD-Package~31bf3856ad364e35~wow64~sv-se~" InstalledSize="71290" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="Piubc7AiCwiynfFSzL4BB6x6vU/n0juJl7G/+30mdMs=" PayloadSize="36100" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-PowerShell-ISE-FOD-Package~31bf3856ad364e35~wow64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Printing-PMCPPC-FoD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="225424" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="13PHja7lCepzE6AE/3aQFOypCyCIvDbRvNkYd4ws8/o=" PayloadSize="47153" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-Printing-PMCPPC-FoD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Printing-WFS-FoD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="526278" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="DmxIHlXAX+RHmSV4LBEAI+VVHdZyH420Y32SPXDiksg=" PayloadSize="144586" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-Printing-WFS-FoD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="226249" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="P2zQPfkjBT/ksi4rd8twXcLhTWJurhDsANli7Nn4s/c=" PayloadSize="76870" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~wow64~sv-se~" InstalledSize="397823" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="lTDWldm+NPnwPZOFXKAFBod/EQig8xFGXjmwHTgcBgM=" PayloadSize="275907" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~wow64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RasRip-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="25425" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="nrYqcReMJoCsf7p2H1DQD8q/04I6Bx6Va74VUkTikqQ=" PayloadSize="20135" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-RasRip-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~amd64~sv-se~" InstalledSize="18556188" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="WxCCyyrmMAa6wYFo5otXR5nhT48xhcV9BJ106SJg3pc=" PayloadSize="4016915" Path="FeaturesOnDemand\sv-se\cabs\Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~amd64~sv-se~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~wow64~sv-se~" InstalledSize="12837" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="sv-SE" />
        </ApplyToInfo>
 ,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAA;YAC9D,CAAC,CAAC,CAAA;SACH;aAAM;YACL,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAA;SAC7D;QACD,OAAO,IAAI,CAAC,OAAO,CAAA;IACrB,CAAC;IAED,UAAU;QACR,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE;YACzB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAA;SACtB;QACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAA;QACnE,OAAO,IAAI,CAAC,OAAO,CAAA;IACrB,CAAC;CACF","sourcesContent":["/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Path\n  : O extends GWOFileTypesFalse\n  ? string\n  : O extends GWOFileTypesUnset\n  ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Set<Path>\n  : O extends GWOFileTypesFalse\n  ? Set<string>\n  : O extends GWOFileTypesUnset\n  ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts\n): IgnoreLike =>\n  typeof ignore === 'string'\n    ? new Ignore([ignore], opts)\n    : Array.isArray(ignore)\n    ? new Ignore(ignore, opts)\n    : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    if (opts.ignore) {\n      this.#ignore = makeIgnore(opts.ignore, opts)\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? await e.lstat() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = await s.realpath()\n      /* c8 ignore start */\n      if (target && (target.isUnknown() || this.opts.stat)) {\n        await target.lstat()\n      }\n      /* c8 ignore stop */\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return e &&\n      (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n      (!ifDir || e.canReaddir()) &&\n      (!this.opts.nodir || !e.isDirectory()) &&\n      (!this.opts.nodir ||\n        !this.opts.follow ||\n        !e.isSymbolicLink() ||\n        !e.realpathCached()?.isDirectory()) &&\n      !this.#ignored(e)\n      ? e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? e.lstatSync() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = s.realpathSync()\n      if (target && (target?.isUnknown() || this.opts.stat)) {\n        target.lstatSync()\n      }\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep)\n          ? '.' + this.#sep\n          : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb)\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  matches: O extends GWOFileTypesTrue\n    ? Set<Path>\n    : O extends GWOFileTypesFalse\n    ? Set<string>\n    : O extends GWOFileTypesUnset\n    ? Set<string>\n    : Set<Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.matches = new Set() as Matches<O>\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Matches<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Matches<O> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  results: O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass({\n      signal: this.signal,\n      objectMode: true,\n    }) as MatchStream<O>\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n"]}